# Testing wtih Google Test `gtest`

## Significance of testing

Testing is an essential aspect of software development that ensures the reliability, functionality, and performance of code. It helps identify bugs, verify that code meets requirements, and provides confidence in the software's correctness.

## Types of Testing

(Note: this section is generated by GPT) 

### Unit Testing
Unit testing involves testing individual components or functions in isolation to verify their correctness. It helps catch bugs early in the development process and ensures that each unit of code works as expected.

### Integration Testing
Integration testing focuses on testing the interactions between different components or modules to ensure that they work together as intended. It helps identify issues that may arise when combining various parts of the software.

### Other Categories of Testing
- **Functional Testing:** Validates that the software functions according to specified requirements.
- **Performance Testing:** Evaluates the system's responsiveness, speed, and overall performance.
- **Regression Testing:** Ensures that new changes do not negatively impact existing functionalities.

## Using Google Test in C++ as an Example

Google Test is a popular C++ testing framework that supports test-driven development.

### Install Google Test

Install with `apt-get`:

```bash
sudo apt-get install -y libgtest-dev
```

Or build from source by cloning the Google Test repository:

```bash
git clone https://github.com/google/googletest.git
cd googletest
mkdir build && cd build
cmake ..
make
sudo make install
```

### Write Tests - Unit tests

The standardized way to write unit test conforming to `CppCoreGuidelines` is to write a header and cpp test file for each header (or cpp). Suppose we want to write unit-test for our IO flow encoded in `/include/io.hpp` and `/src/io.cpp`. In this case, under `/tests/` folder, create `/tests/test_io.hpp` and `/tests/test_io.cpp` (name according to the convention for your repository). Link `gtest` and required headers in `/tests/test_io.hpp` - as an example:

```hpp
#pragma once

#include <gtest/gtest.h>    ///<< include Google test
#include <vector>           ///<< include modules you are using, such as std::vector in this case
#include "io.hpp"           ///<< include headers you are testing and other required headers to run your tests here
```

Include `test_io.hpp` and write tests in `/tests/test_io.cpp` by implementing `TEST` from `gtest.h`:

```cpp
#include "test_io.hpp"

TEST(test_suite_name, test_name){
    // ... write your test here ..
}

// Example
TEST(PopSpaceTest, BasicTest)
{
    EXPECT_EQ(pop_space("Hello World"), "HelloWorld");
    EXPECT_EQ(pop_space("Spaces   Removed"), "SpacesRemoved");
    EXPECT_EQ(pop_space("\tTabs\tRemoved"), "TabsRemoved");
    EXPECT_EQ(pop_space("Mixed\t\tSpaces \tRemoved"), "MixedSpacesRemoved");
}

// Be careful for float and double - use EXPECT_DOUBLE_EQ
TEST(ParameterTest, ImportParamFile)
{
    // ... import parameter file
    EXPECT_DOUBLE_EQ(testParam.timeStep, 0.001);
}
```


### Modify Makefile

Include testing targets in your Makefile to make both main executable and test executable:

```make
CXX = g++
CXXFLAGS = -O3 -std=c++0x -I./tests -I/usr/include -Iinclude -Itests

all: your_program your_test_executable

your_program: main.cpp
	$(CXX) $(CXXFLAGS) main.cpp -o your_program

your_test_executable: tests/test_linear_algebra.cpp
	$(CXX) $(CXXFLAGS) -c tests/test_linear_algebra.cpp -o obj/test_linear_algebra.o
	$(CXX) $(CXXFLAGS) obj/test_linear_algebra.o -o your_test_executable $(LIBS)
	./your_test_executable
```

If you instead want to keep the program and executable separate with make goals,
add if statements to specify:

```make
ifeq (test,$(MAKECMDGOALS))
	_EXEC = test_main
endif

# Add gtest to library if running unittest
ifeq (test,$(MAKECMDGOALS))
	LIBS += -lgtest -lgtest_main -pthread
	CXXFLAGS += -I./tests
	INCS += -Itests
endif
```

### GitHub Actions Integration

Github Actions integration of testing enables automatically building and testing every time
the repo is changed. Github Actions currently (01/16/2024) allow 2000 Linux computer minutes of Github Actions Integration per month per free account. This is very adequate for building and unit-testing (which usually takes fewer than 10 computer minutes). If you have not tweaked around the monthly spending quota, it should be automatically set to $0, which means Github Actions will stop if 2k comp min is used up. You can check it under your Github > Settings > Access - Billing and Plans - Plans and Usage > Usage this month.

DO NOT run trial runs before your calculate computer minutes - this may potentially leads to a large bill!

Create a `.github/workflows/c-cpp.yml` file:

```yaml
name: C/C++ CI

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y libgtest-dev

    - name: Build and run tests
      run: |
        make
        ./your_test_executable
```

If you chose to keep the program and executable separate with make goals in the previous section, you need to specify make goals here. For example:

```yaml
    - name: Build and run tests
      run: |
        make test
        ./bin/test_main
```

If instead using `cmake`, add the corresponding lines to `Install dependencies` section:

```yaml
    - name: Install dependencies
      run: |
        sudo apt-get install -y cmake
        cd /usr/src/gtest
        sudo cmake CMakeLists.txt
        sudo make
        sudo cp *.a /usr/lib
```



This example GitHub Actions workflow installs dependencies and runs tests on each push to the main branch. From my experience, the VM on Github Action comes with GNU scientific library `gsl`. However, in case of missing `gsl`, add following line to `Install dependencies` section:

```yaml
sudo apt-get install libgsl-dev
```

Now push your changes and go to your Github repository > Actions to check the progress of your C/C++ CI.
